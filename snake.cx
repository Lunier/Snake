package main

import "stuff"
import "gl"
import "glfw"
import "gltext"
import "os"

var PI f32 = 3.1459

//Boolean to determine if the user wants to restart the game
var restart bool = false

//Determine how often per second the snake moves
var SPEED f64 = 0.25D

//Keyboard Keys
var RIGHT_ARROW_KEY i32 = 262
var LEFT_ARROW_KEY i32 = 263
var DOWN_ARROW_KEY i32 = 264
var UP_ARROW_KEY i32 = 265
var ENTER_KEY i32 = 257

// Directions
var UP i32 = 0
var RIGHT i32 = 1
var DOWN i32 = 2
var LEFT i32 = 3

// Set up the points you get for every food
var POINTSFORFOOD i32 = 5

//WindowSize
var WIDTH_WINDOW i32 = 600
var HEIGHT_WINDOW i32 = 600

//start position of the snake
var X_START i32 = 11
var Y_START i32 = 11

//Maximum Gamefields
var X_CELLS i32 = 20
var Y_CELLS i32 = 20

//Width and Height of a Cell
var WIDTH_CELLS f32 = 0.0
var HEIGHT_CELLS f32 = 0.0

//Padding between rectangles
var PADDING f32 = 0.0

var gamefield [20][20]Cell

var food stuff.Food

var player stuff.Player

func initGlfw(window str) () {

    glfw.Init()
    glfw.WindowHint(glfw.Resizable,glfw.False)
    glfw.WindowHint(glfw.ContextVersionMajor, 2)
    glfw.WindowHint(glfw.ContextVersionMinor, 1)

    glfw.CreateWindow(window,WIDTH_WINDOW,HEIGHT_WINDOW,"Snake v1.0")
    glfw.MakeContextCurrent(window)
}

func initGl() (program i32) {
    gl.Init()
    var program i32
    program = gl.CreateProgram()
    gl.LinkProgram(program)
}

func setupCellSpecs() (){
    WIDTH_CELLS = f32.div(2.0, i32.f32(X_CELLS))
    HEIGHT_CELLS = f32.div(2.0, i32.f32(Y_CELLS))
    PADDING = f32.div(WIDTH_CELLS, 20.0)
}

/* Function     : initScene
   Desctription : Responsible for the grey tiles-Background
*/
func initScene() (){
    gl.Clear(i32.bitor(gl.COLOR_BUFFER_BIT, gl.DEPTH_BUFFER_BIT))
	gl.Disable(gl.DEPTH_TEST)
	gl.MatrixMode(gl.PROJECTION)
	gl.LoadIdentity()
	gl.MatrixMode(gl.MODELVIEW)

	initGamefield()
	drawBoard()
	initPlayer()
	drawPlayer()
	createFood()
    drawFood()
}

func initGamefield()(){
    var i i32
    var j i32

    for i = 0; i < Y_CELLS; i++
    {
		for j=0; j < X_CELLS; j++
		{
			gamefield[i][j] = initCell(i,j,0)
		}
    }
}

func initCell(line i32, column i32, art i32) (cell stuff.Cell) {
    var pos stuff.Position2D
    pos = indexToPosition(line,column)

    var dimension stuff.Dimension2D
    dimension = stuff.newDimension2D(HEIGHT_CELLS,WIDTH_CELLS)

    var cell stuff.Cell
    cell = stuff.newCell(pos,dimension,getColor("cell"))

    return cell
}

func indexToPosition (line i32, column i32) (pos stuff.Position2D){
    var x f32 = f32.add(f32.add(-1.0, f32.mul(i32.f32(column),WIDTH_CELLS)),f32.div(WIDTH_CELLS,2.0))
    var y f32 = f32.sub(f32.sub( 1.0, f32.mul(i32.f32(line),HEIGHT_CELLS)), f32.div(HEIGHT_CELLS,2.0))
    var pos stuff.Position2D
    pos = stuff.newPosition2D(x,y,column,line)

    return pos
}

func getColor(name str) (color stuff.Color){
    if str.eq(name,"food"){
        color = stuff.newColor(0.04, 0.92, 0.51)
    }
    if str.eq(name,"cell"){
		color = stuff.newColor(0.8, 0.8, 0.8)
    }
    if str.eq(name,"player"){
        color = stuff.newColor(0.0, 0.25,1.0)
    }
    
    return color
}

func drawRectangle(pos stuff.Position2D, dim stuff.Dimension2D, color stuff.Color){
    gl.Begin(gl.QUADS)
    gl.Color3f(color.red, color.green, color.blue)

    gl.Vertex2f(f32.add(f32.sub(pos.x,f32.div(dim.width,2.0)),PADDING), f32.sub(f32.add(pos.y,f32.div(dim.height,2.0)),PADDING))
    gl.Vertex2f(f32.add(f32.sub(pos.x,f32.div(dim.width,2.0)),PADDING), f32.add(f32.sub(pos.y,f32.div(dim.height,2.0)),PADDING))
    gl.Vertex2f(f32.sub(f32.add(pos.x,f32.div(dim.width,2.0)),PADDING), f32.add(f32.sub(pos.y,f32.div(dim.height,2.0)),PADDING))
    gl.Vertex2f(f32.sub(f32.add(pos.x,f32.div(dim.width,2.0)),PADDING), f32.sub(f32.add(pos.y,f32.div(dim.height,2.0)),PADDING))
    
    gl.End()
}

func drawBoard()(){
    var i i32
    var j i32

    for i = 0; i < Y_CELLS; i++
    {
		for j=0; j < X_CELLS; j++
		{
			drawRectangle(gamefield[i][j].position, gamefield[i][j].dimension, gamefield[i][j].color)
		}
    }
}

/* Function     : createFood
   Desctription : Creates a new Food and assigns it to the global variable
*/
func createFood()(){
    var playerPosition stuff.Position2D
    playerPosition = player.position
    var x i32 = i32.rand(0, i32.sub(X_CELLS,1))
    var y i32 = i32.rand(0, i32.sub(Y_CELLS,1))
    for bool.or(bool.and(i32.eq(x,playerPosition.realX), i32.eq(y,playerPosition.realY)),onBody(x,y)){
    	x = i32.rand(0, i32.sub(X_CELLS,1))
    	y = i32.rand(0, i32.sub(Y_CELLS,1))
    }
    var pos stuff.Position2D
    pos = indexToPosition(y,x)

    var dimension stuff.Dimension2D
    dimension = stuff.newDimension2D(HEIGHT_CELLS,WIDTH_CELLS)

    food = stuff.newFood(pos,dimension,getColor("food"))
}

func onBody(x i32, y i32)(answer bool){
	answer = false
	var i i32
	var max i32 = player.size
	for i=0; i<max;i++{
		var tempCellArr [99]stuff.Cell
		tempCellArr = player.body
		var tempCell stuff.Cell = tempCellArr[i]		
		var pos stuff.Position2D = tempCell.position
		if bool.and(i32.eq(pos.realY,y),i32.eq(pos.realX,x)){
			answer = true
			return answer
		}
	}
	return answer
}
func drawFood()(){
    var color stuff.Color = food.color
    var pos stuff.Position2D = food.position
    var dim stuff.Dimension2D = food.dimension
    gl.Begin(gl.QUADS)
    gl.Color3f(color.red, color.green, color.blue)

    gl.Vertex2f(f32.add(pos.x,PADDING), 								f32.sub(f32.add(pos.y,f32.div(dim.height,2.0)),PADDING))
    gl.Vertex2f(f32.add(f32.sub(pos.x,f32.div(dim.width,2.0)),PADDING), f32.add(pos.y,PADDING))
    gl.Vertex2f(f32.sub(pos.x,PADDING), 								f32.add(f32.sub(pos.y,f32.div(dim.height,2.0)),PADDING))
    gl.Vertex2f(f32.sub(f32.add(pos.x,f32.div(dim.width,2.0)),PADDING), f32.sub(pos.y,PADDING))

    gl.End()
}

func initPlayer()(){
    var pos stuff.Position2D
    pos.realX = X_START
	pos.realY = Y_START

    var dim stuff.Dimension2D
    dim = stuff.newDimension2D(HEIGHT_CELLS,WIDTH_CELLS)
    
    player = stuff.newPlayer(pos,dim,getColor("player"))
}

func addElementToBody()(){
    var playerPosition stuff.Position2D
    playerPosition = player.position
	var playerSize i32 = player.size
	var dimension stuff.Dimension2D
	var color stuff.Color
	var pos stuff.Position2D

	if (playerSize == 0){
    	pos = indexToPosition(playerPosition.realY,playerPosition.realX)
	}else {
		playerSize = i32.sub(playerSize,1)
		var tCellArr [99]stuff.Cell
		tCellArr = player.body
		var tCell stuff.Cell
		tCell = tCellArr[playerSize]

		var lastElement stuff.Position2D
		lastElement = tCell.position

		pos = indexToPosition(lastElement.realY,lastElement.realX)

		playerSize = i32.add(playerSize,1)
	}
	
	dimension = stuff.newDimension2D(HEIGHT_CELLS,WIDTH_CELLS)

	var tempCell [99]stuff.Cell
	tempCell = player.body
	tempCell[playerSize] = stuff.newCell(pos,dimension,getColor("player"))
	player.body = tempCell
	player.size = i32.add(player.size,1)
}

func drawPlayer()(){
    var color stuff.Color = player.color
    var pos stuff.Position2D = player.position
    pos = indexToPosition(pos.realY,pos.realX)
    var dim stuff.Dimension2D = player.dimension


    gl.Begin(gl.TRIANGLES)
    gl.Color3f(color.red, color.green, color.blue)
	
	drawHead(player.direction,pos.x,pos.y,dim.height,dim.width)
	
    gl.End()


	var i i32
	var max i32 = player.size
	for i=0; i<max;i++{
		var tempCellArr [99]stuff.Cell
		tempCellArr = player.body
		var tempCell stuff.Cell= tempCellArr[i]		
		pos = tempCell.position
		pos = indexToPosition(pos.realY,pos.realX)
        color = tempCell.color
		dim = tempCell.dimension
		drawRectangle(pos,dim,color)
	}
}

func drawHead(dir i32,x f32, y f32, h f32, w f32)(){
	if i32.eq(dir, UP){
    	gl.Vertex2f(x,y+h/2.0-PADDING)
		gl.Vertex2f(x-w/2.0+PADDING,y-h/2.0+PADDING)
		gl.Vertex2f(x+w/2.0-PADDING,y-h/2.0+PADDING)
    }
    if i32.eq(dir, RIGHT){
		gl.Vertex2f(x+w/2.0-PADDING,y)
		gl.Vertex2f(x-w/2.0+PADDING,y+h/2.0-PADDING)
		gl.Vertex2f(x-w/2.0+PADDING,y-h/2.0+PADDING)
    }
    if i32.eq(dir, DOWN){
    	gl.Vertex2f(x,y-h/2.0-PADDING)
		gl.Vertex2f(x-w/2.0+PADDING,y+h/2.0-PADDING)
		gl.Vertex2f(x+w/2.0-PADDING,y+h/2.0-PADDING)
    }
    if i32.eq(dir, LEFT){
		gl.Vertex2f(x-w/2.0+PADDING,y)
		gl.Vertex2f(x+w/2.0-PADDING,y+h/2.0-PADDING)
		gl.Vertex2f(x+w/2.0-PADDING,y-h/2.0+PADDING)
    }
}
func renderScreen()(){
    drawBoard()
    drawPlayer()
    drawFood()
}

func keyControl(window str, key i32, scancode i32, action i32, mods i32)(){
    if bool.and(i32.eq(key, RIGHT_ARROW_KEY), i32.eq(action, 1)) {
		changeDir(RIGHT)
    }
    if bool.and(i32.eq(key, LEFT_ARROW_KEY), i32.eq(action, 1)) {
		changeDir(LEFT)
    }
    if bool.and(i32.eq(key, DOWN_ARROW_KEY), i32.eq(action, 1)) {
		changeDir(DOWN)
    }
    if bool.and(i32.eq(key, UP_ARROW_KEY), i32.eq(action, 1)) {
		changeDir(UP)
    }
	if bool.and(i32.eq(key, ENTER_KEY), i32.eq(action, 1)){
		restart = true
	}
}

func changeDir(direction i32)(){
    if bool.and(bool.not(i32.eq(player.direction,DOWN)),i32.eq(direction, UP)){
		player.direction = UP
    }
    if bool.and(bool.not(i32.eq(player.direction,LEFT)),i32.eq(direction, RIGHT)){
		player.direction = RIGHT
    }
    if bool.and(bool.not(i32.eq(player.direction,UP)),i32.eq(direction, DOWN)){
		player.direction = DOWN
    }
    if bool.and(bool.not(i32.eq(player.direction,RIGHT)),i32.eq(direction, LEFT)){
		player.direction = LEFT
    }
}

func movePlayer()(){
    if (bool.eq(allowedToMove(),true)){
		var pos stuff.Position2D
		pos = player.position

		var dir i32 = player.direction

		var tempCellArr [99]stuff.Cell = player.body

		var max i32 = i32.sub(player.size,1)

		var tempCell stuff.Cell = tempCellArr[max]

		var lastElement stuff.Position2D = tempCell.position

		lastElement.realY = pos.realY
		lastElement.realX = pos.realX

		if i32.eq(dir, UP){
			pos.realY = i32.sub(pos.realY,1)
		}
		if i32.eq(dir, RIGHT){
			pos.realX = i32.add(pos.realX,1)
		}
		if i32.eq(dir, DOWN){
			pos.realY = i32.add(pos.realY,1)
		}
		if i32.eq(dir, LEFT){
			pos.realX = i32.sub(pos.realX,1)
		}
		player.position = pos

		tempCell.position = lastElement
		tempCellArr[max] = tempCell
		player.body = tempCellArr

		switchBodyElements()
	} else {
		player.alive = false
	}
}

func allowedToMove()(allowed bool){
	allowed = true
	var nextPlayerPos stuff.Position2D = player.position
	var dir i32 = player.direction
	
	//set the variable nextPlayerPos to the position the player would go if he is allowed
	if i32.eq(dir, UP){
    	nextPlayerPos.realY = i32.sub(nextPlayerPos.realY,1)
    }
    if i32.eq(dir, RIGHT){
    	nextPlayerPos.realX = i32.add(nextPlayerPos.realX,1)
    }
    if i32.eq(dir, DOWN){
		nextPlayerPos.realY = i32.add(nextPlayerPos.realY,1)
    }
    if i32.eq(dir, LEFT){
		nextPlayerPos.realX = i32.sub(nextPlayerPos.realX,1)
    }
	
	//check if the player would collide with himself
	var i i32
	var max i32 = i32.sub(player.size,1)
	for i=0; i<max;i++{
		var pos stuff.Position2D
		var tempCellArr [99]stuff.Cell
		tempCellArr = player.body
		var tempCell stuff.Cell= tempCellArr[i]		
		pos = tempCell.position
		if bool.and(i32.eq(nextPlayerPos.realY,pos.realY),i32.eq(nextPlayerPos.realX,pos.realX)){		
			allowed = false
			return allowed
		}
	}

	//check if the player would be outside of the gamefield
	if bool.or(bool.or(i32.eq(nextPlayerPos.realY,-1),i32.eq(nextPlayerPos.realY,Y_CELLS)),bool.or(i32.eq(nextPlayerPos.realX,-1),i32.eq(nextPlayerPos.realX,X_CELLS))){
		allowed = false
		return allowed
	}

	return allowed
}

func switchBodyElements()(){
	var i i32
	var max i32 = i32.sub(player.size,1)
	var tempCellArr [99]stuff.Cell = player.body
	var pos stuff.Position2D
	for i=max; i > 0; i--
	{
		var temp stuff.Cell
		temp = tempCellArr[i]
		tempCellArr[i] = tempCellArr[i32.sub(i,1)]
		tempCellArr[i32.sub(i,1)] = temp
	}
	player.body = tempCellArr
}

func checkForFood()(){
	var foodPos Position2D = food.position
    var playerPos Position2D = player.position

	if bool.and(i32.eq(foodPos.realX,playerPos.realX),i32.eq(foodPos.realY,playerPos.realY)){
		createFood()
		addElementToBody()
		player.score = i32.add(player.score,POINTSFORFOOD)
	}
}

func setupText()(){
	var wd str
	wd = os.GetWorkingDirectory()
	fontFile := str.concat(wd, "fonts/roboto-light.ttf")

	os.Open(fontFile)
	gltext.LoadTrueType("Roboto100", fontFile, 100, 32, 127, gltext.LeftToRight)
	os.Close(fontFile)
	
	os.Open(fontFile)
	gltext.LoadTrueType("Roboto50", fontFile, 50, 32, 127, gltext.LeftToRight)
	os.Close(fontFile)

	os.Open(fontFile)
	gltext.LoadTrueType("Roboto30", fontFile, 30, 32, 127, gltext.LeftToRight)
	os.Close(fontFile)

}

func printScore()(){
	var playerScore str = str.concat("Score: ", i32.str(player.score))
	var newGame str 
	newGame = "Enter to start a new Game"
	gltext.Printf("Roboto50",200.0, 250.0, playerScore)
	gltext.Printf("Roboto30",100.0, 340.0, newGame)
}

func main() {

    initGlfw("window")
    var program i32 = initGl()
	
	new_game:
	restart = false
	setupText()
    setupCellSpecs()
    initScene()

    glfw.SetKeyCallback("window","keyControl")
    
	var timer f64 = glfw.GetTime()
    for bool.not(glfw.ShouldClose("window")){
		gl.Clear(i32.bitor(gl.COLOR_BUFFER_BIT, gl.DEPTH_BUFFER_BIT))
	    gl.UseProgram(program)
	
		
		if (player.alive == true){
			renderScreen()
			checkForFood()
		
			//check if the time has passed to move again
			if f64.lt(SPEED,f64.sub(glfw.GetTime(),timer)){
				movePlayer()
				timer = glfw.GetTime()
			}
		}else {
			printScore()
			if (restart == true){
				goto new_game
			}
		}
        glfw.PollEvents()
        glfw.SwapBuffers("window")
    }
}
